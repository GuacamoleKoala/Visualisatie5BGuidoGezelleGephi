<!DOCTYPE html>
<html>
<head>
    <title>Gezelle Netwerk Visualisatie</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        /* Basisstijlen voor de container */
        #mynetwork {
            width: 100%;
            height: 600px; 
            border: 1px solid lightgray;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
        }
        body { font-family: Arial, sans-serif; padding: 20px; }

        /* Stijlen voor de controlebalk (jaartallen, reset) */
        .controls { 
            margin-bottom: 20px; 
            padding: 15px; 
            border: 1px solid #ddd; 
            background-color: #f9f9f9; 
            display: flex; 
            align-items: center;
        }
        .controls label, .controls input { margin-right: 20px; }
        
        /* Stijlen voor de functionele knoppen */
        .functional-button { 
            padding: 10px 15px; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
            margin-left: 10px;
        }
        #resetButton { background-color: #007bff; margin-left: auto; }
        #resetButton:hover { background-color: #0056b3; }
        #legendToggleButton, #infoButton { background-color: #28a745; }
        #legendToggleButton:hover, #infoButton:hover { background-color: #1e7e34; }


        /* Stijlen voor de Legende en Info Pop-up */
        .overlay-container {
            position: absolute;
            top: 100px;
            right: 20px;
            z-index: 1000; /* Zorg dat deze boven de visualisatie ligt */
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 350px;
        }

        #legendContainer { display: none; } /* Standaard verborgen */
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #333;
        }

    </style>
</head>
<body>

    <h1>Netwerk Visualisatie</h1>

    <div class="controls">
        <label for="startYear">Start Jaar:</label>
        <input type="number" id="startYear" value="1870" min="1800" max="1950" onchange="filterAndDraw()">

        <label for="endYear">Eind Jaar:</label>
        <input type="number" id="endYear" value="1890" min="1800" max="1950" onchange="filterAndDraw()">
        
        <p style="margin-top: 10px; margin-right: 20px;">Gefilterde knooppunten: <strong id="nodeCount">0</strong> | Gefilterde randen: <strong id="edgeCount">0</strong></p>

        <button id="legendToggleButton" class="functional-button" onclick="toggleLegend()">Legende Tonen</button>
        <button id="infoButton" class="functional-button" onclick="showInfo()">Meer Info</button>
        <button id="resetButton" class="functional-button" onclick="resetView()">Reset Weergave</button>
    </div>

    <div id="mynetwork"></div>

    <div id="legendContainer" class="overlay-container">
        <h3>Legende</h3>
        <p>De kleur en grootte van de knooppunten (Nodes) geven het type en de verbondenheid aan.</p>
        <div id="legendList">
            </div>
    </div>

    <script type="text/javascript">
        let allNodes = [];
        let allEdges = [];
        let network = null;
        let originalNodesData = null; 
        let originalEdgesData = null; 
        const container = document.getElementById('mynetwork');
        let selectedNode = null; // Houd de geselecteerde knoop bij

        // --- Vis.js Options (Fysica uitgeschakeld voor vaste lay-out) ---
        const options = {
            nodes: {
                shape: 'dot',
                font: { size: 12, color: '#333' },
                borderWidth: 2
            },
            edges: {
                arrows: 'to',
                color: { inherit: true },
                smooth: { type: 'continuous' }
            },
            // Zorgt ervoor dat de lay-out vast blijft (gebruikt X, Y uit CSV)
            physics: {
                enabled: false 
            }
        };
        // --------------------------------------------------------------------

        // --- Data Laden en Parsen Functies ---
        async function loadData() {
            try {
                // Let op: CSV files moeten in dezelfde map staan!
                const nodesData = await parseCSV('nodes.csv');
                allNodes = nodesData.map(d => ({
                    id: d.Id, 
                    label: d.Label, 
                    group: d.category, 
                    title: `Naam: ${d.Label}\nType: ${d.category}\nStart: ${d.startyearcorfixvalue}\nEind: ${d.endyearcor}`,
                    startYear: parseInt(d.startyearcorfixvalue), 
                    endYear: parseInt(d.endyearcor),
                    size: parseFloat(d.Size) || 15,
                    color: d.Color,
                    x: parseFloat(d.X), 
                    y: parseFloat(d.Y),
                    fixed: true 
                }));

                const edgesData = await parseCSV('edges.csv');
                allEdges = edgesData.map(d => ({
                    id: d.Id, 
                    from: d.Source, 
                    to: d.Target, 
                    label: d.rollabel, 
                    title: `Relatie: ${d.rollabel}\nJaar: ${d.finalstartyearfixvalue}-${d.finalendyearfixvalue}`,
                    startYear: parseInt(d.finalstartyearfixvalue), 
                    endYear: parseInt(d.finalendyearfixvalue),
                    color: d.Color
                }));
                
                filterAndDraw();
                buildLegend(); // Bouw de legende nadat de data geladen is

            } catch (error) {
                console.error("Fout bij het laden van de bestanden:", error);
                // Vriendelijke foutmelding in de container
                container.innerHTML = "<h2>Data Laadfout: Netwerk is leeg</h2><p>Controleer of de bestanden **'nodes.csv'** en **'edges.csv'** correct zijn en in de juiste map staan. Druk op F12 en bekijk de **Console** voor gedetailleerde fouten.</p>";
            }
        }

        function parseCSV(url) {
            return new Promise((resolve, reject) => {
                const attemptParse = (delimiter = ',', callback) => {
                    Papa.parse(url, {
                        download: true,
                        header: true,
                        skipEmptyLines: true,
                        delimiter: delimiter,
                        complete: callback,
                        error: (error) => reject(error)
                    });
                };

                // Probeer komma, daarna puntkomma (voor Europese formats)
                attemptParse(',', (results) => {
                    if (results.data.length > 0) {
                        return resolve(results.data);
                    }
                    attemptParse(';', (resultsSemi) => {
                        if (resultsSemi.data.length > 0) {
                            return resolve(resultsSemi.data);
                        }
                        reject(new Error(`CSV-bestand ${url} is leeg of kon niet correct worden geparst.`));
                    });
                });
            });
        }
        // --------------------------------------------------------------------


        // --- Filtering en Drawing Functies ---
        function filterAndDraw() {
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);

            if (isNaN(startYear) || isNaN(endYear)) return;

            const filteredEdges = allEdges.filter(edge => {
                return edge.startYear <= endYear && edge.endYear >= startYear;
            });

            const connectedNodeIds = new Set();
            filteredEdges.forEach(edge => {
                connectedNodeIds.add(edge.from);
                connectedNodeIds.add(edge.to);
            });

            const filteredNodes = allNodes.filter(node => {
                return connectedNodeIds.has(node.id);
            });
            
            document.getElementById('nodeCount').textContent = filteredNodes.length;
            document.getElementById('edgeCount').textContent = filteredEdges.length;

            originalNodesData = new vis.DataSet(filteredNodes);
            originalEdgesData = new vis.DataSet(filteredEdges);

            const data = {
                nodes: originalNodesData,
                edges: originalEdgesData
            };

            if (network) {
                network.setData(data);
                network.fit(); 
            } else {
                network = new vis.Network(container, data, options);
                network.on("click", handleNodeClick);
                network.fit(); // Centreer direct bij het opstarten
            }
            
            selectedNode = null; // Reset de selectie
            resetHighlighting(false); // Reset de highlighting
        }
        // --------------------------------------------------------------------


        // --- Click Handler Functies (Nieuwe logica voor reset bij dubbelklik/selectie) ---

        /**
         * Reset de weergave en centreren.
         */
        function resetView() {
            filterAndDraw(); 
            selectedNode = null;
        }
        
        /**
         * Reset de highlighting van alle nodes en edges.
         * @param {boolean} unselect - Indien true, wordt de Vis.js selectie ook ongedaan gemaakt.
         */
        function resetHighlighting(unselect = true) {
            if (!originalNodesData || !originalEdgesData) return;

            const updatedNodes = [];
            const updatedEdges = [];

            // Reset stijlen van nodes
            originalNodesData.forEach(node => {
                updatedNodes.push({
                    id: node.id,
                    opacity: 1.0,
                    color: node.color,
                    borderWidth: 2
                });
            });

            // Reset stijlen van edges
            originalEdgesData.forEach(edge => {
                updatedEdges.push({
                    id: edge.id,
                    width: 1,
                    color: { color: edge.color || '#333', opacity: 1.0 }
                });
            });
            
            originalNodesData.update(updatedNodes);
            originalEdgesData.update(updatedEdges);
            
            if (unselect && network) {
                network.unselectAll();
            }
        }
        
        /**
         * Behandelt de klik op een node of op de achtergrond.
         */
        function handleNodeClick(params) {
            const clickedNodeId = params.nodes.length > 0 ? params.nodes[0] : null;

            // Logica 1: Klik op dezelfde node (RESET)
            if (clickedNodeId && clickedNodeId === selectedNode) {
                resetHighlighting();
                network.fit(); 
                selectedNode = null;
                return;
            }

            // Logica 2: Klik op de achtergrond of een andere node (RESET en/of SELECT)
            if (clickedNodeId) {
                // Selecteer de nieuwe node
                selectedNode = clickedNodeId;
                highlightNode(selectedNode);
            } else {
                // Klik op de achtergrond (RESET)
                resetHighlighting();
                network.fit(); 
                selectedNode = null;
            }
        }

        /**
         * Highlight een specifieke node en zijn directe connecties.
         */
        function highlightNode(nodeId) {
            const updatedNodes = [];
            const updatedEdges = [];
            const connectedEdges = network.getConnectedEdges(nodeId);
            
            // 1. Zoek alle verbonden nodes
            const connectedNodeIds = new Set();
            connectedEdges.forEach(edgeId => {
                const edge = originalEdgesData.get(edgeId); 
                if (edge) { 
                    if (edge.from !== nodeId) connectedNodeIds.add(edge.from);
                    if (edge.to !== nodeId) connectedNodeIds.add(edge.to);
                }
            });

            // 2. Definieer de updates voor alle nodes
            originalNodesData.forEach(node => {
                const isSelected = node.id === nodeId;
                const isConnected = connectedNodeIds.has(node.id);
                
                let update = { id: node.id };

                if (isSelected || isConnected) {
                    update.opacity = 1.0;
                    update.color = node.color; 
                    update.borderWidth = isSelected ? 3 : 2;
                } else {
                    update.opacity = 0.3;
                    update.color = { background: '#ccc', border: '#999' }; 
                }
                updatedNodes.push(update);
            });

            // 3. Definieer de updates voor alle edges
            originalEdgesData.forEach(edge => {
                const isConnected = connectedEdges.includes(edge.id);
                let update = { id: edge.id };

                if (isConnected) {
                    update.width = 3;
                    update.color = { color: edge.color || '#333', opacity: 1.0 }; 
                } else {
                    update.width = 1;
                    update.color = { color: '#ccc', opacity: 0.1 };
                }
                updatedEdges.push(update);
            });

            // 4. Pas de stijlen toe
            originalNodesData.update(updatedNodes);
            originalEdgesData.update(updatedEdges);
        }
        // --------------------------------------------------------------------


        // --- UI Container Functies (Legende & Info) ---

        /**
         * Bouwt de Legende op basis van de unieke categorieën in de nodes.
         */
        function buildLegend() {
            const legendList = document.getElementById('legendList');
            const uniqueCategories = new Map();

            allNodes.forEach(node => {
                if (!uniqueCategories.has(node.group)) {
                    uniqueCategories.set(node.group, node.color);
                }
            });

            let html = '<h4>Knooppunttypes (Nodes)</h4>';
            uniqueCategories.forEach((color, category) => {
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${color}; border-color: ${color === '#ffffff' ? '#333' : color};"></div>
                        <span>${category}</span>
                    </div>
                `;
            });
            
            html += '<br><h4>Relatietypes (Edges)</h4><p>De lijnen stellen de relatie (*rollabel*) voor en hun kleur is afkomstig van de Edge data.</p>';

            legendList.innerHTML = html;
        }

        /**
         * Toggle de zichtbaarheid van de Legende container.
         */
        function toggleLegend() {
            const container = document.getElementById('legendContainer');
            const button = document.getElementById('legendToggleButton');
            if (container.style.display === 'none' || container.style.display === '') {
                container.style.display = 'block';
                button.textContent = 'Legende Verbergen';
            } else {
                container.style.display = 'none';
                button.textContent = 'Legende Tonen';
            }
        }

        /**
         * Toont een pop-up met achtergrondinformatie.
         */
        function showInfo() {
            alert(
                "Informatie over deze Visualisatie\n\n" +
                "Dit netwerk visualiseert de relaties rond een centrale figuur of een corpus documenten, in dit geval Guido Gezelle en zijn correspondenten. De lay-out is vooraf berekend (via Gephi of een vergelijkbare tool) en vastgezet op basis van X- en Y-coördinaten, wat zorgt voor een stabiele weergave.\n\n" +
                "Functionaliteiten:\n" +
                "1. Tijdlijn: Filter relaties op basis van start- en eindjaar.\n" +
                "2. Interactie: Klik op een knooppunt (Node) om de directe relaties te highlighten. Klik nogmaals op dezelfde knoop, of op de lege achtergrond, om de highlighting te resetten.\n" +
                "3. Reset: De knop 'Reset Weergave' centreert de kaart en reset de filters."
            );
        }

        // Start het proces
        loadData();
    </script>

</body>
</html>
